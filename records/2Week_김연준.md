# 2Week_김연준.md

## Title: [2Week] 김연준

### 필수 미션 요구사항 분석 & 체크리스트
- [x] 한명의 인스타회원이 다른 인스타회원에게 중복으로 호감표시를 할 수 없다. (케이스 4)
- [x] 한명의 인스타회원이 11명 이상의 호감상대를 등록 할 수 없다. (케이스 5)
- [x] (케이스 4) 가 발생했을 때 기존의 사유와 다른 사유로 호감을 표시하는 경우에는 성공으로 처리 (케이스 6)
### 선택 미션 요구사항 분석 & 체크리스트
- [x] 네이버 로그인으로도 로그인이 가능해야 한다.
- [x] 스프링 OAuth2 클라이언트로 구현해야한다.
- [x] member 테이블의 username 에 개인의 이름과 성별등과 같은 부가 정보는 포함되지 않아야 한다. 
---

- 케이스 4, 5, 6 구현
- 네이버 로그인 구현
### 1주차 미션 요약

---

**[접근 방법]**



- 호감 표시 중복 처리
  - 같은 유저를 2번이나 호감 표시할 때 중복될 수 없다는 메시지 반환
  - 중복으로 호감 표시를 했지만 호감 사유를 다르게 했을 때에는 호감 사유만 변경됨
- 호감 표시 제한
  - 유지 보수를 고려해 표시 수 제한값은 yml파일에 선언하여 AppConfig클래스에서 주입받은 값을 전역에서 참조할 수 있는 형태로 변환
  - 호감을 표시한 인스타 계정수가 10개를 넘어가면 예외 처리하여 표시 수 제한
- 네이버 로그인을 했을 때
  - 타소셜로그인(구글, 카카오)와 다르게 JSON형태로 id값 뿐만 아니라 주소, 이메일 등과 같은 부가 정보도 함께 출력됨
  - 때문에 provider타입이 NAVER라면 따로 가공 처리를 함 


**[특이사항]**

아쉬웠던 점
- 케이스 4, 5, 6을 충족시키는 코드를 구현하는 과정에서 모듈식으로 구현하지 못해 코드 가독성이 좋지 못하다는 점
- jpa레파지토리의 쿼리 메소드 작성법에 대한 이해도가 없어 findByFromInstaMemberIdAndToInstaMemberId 처럼 작성했다는 점

궁금했던 점
- update를 하려는 엔티티가 빌더패턴으로 작성되있다면 어떻게 처리를 하는지 궁금합니다. 
- 저는 빌더패턴을 잘 몰라 따로 update메소드를 해당 엔티티에 추가적으로 구현해주는 방식으로 처리했는데 이 방법으로 하는게 맞나요?
- 테이블로부터 조인해서 가져올 때 jpa레파지토리의 쿼리 메소드 방식과 jpql을 이용한 방식 둘 중 뭐가 주로 쓰이는지 궁금합니다.

**[Refactoring]**
